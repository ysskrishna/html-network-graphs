<!-- https://docs.anychart.com/Basic_Charts/Network_Graph#individual_edges -->
<!-- 
  TODOS:
  1. Add ID param in GET API to get only relevent entities and connections
  2. Add legend 
  3. Add order of precendce
  Custom tooltip: https://jsfiddle.net/BlackLabel/4d3pmz7n/1/
 -->
<html>
  <head>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/networkgraph.js"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js"></script>

    <style type="text/css">
      html, body, #container {
        min-width: 320px;
        max-width: 800px;
        margin: 0 auto;
        height: 500px;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script>
      const authToken = "Basic c3VwZXJ1c2VyOiR1cGVyVSRlciE=";
      // Defining async function
      async function fetchGraphData() {
        const data = await fetch("https://contactsdatabase.radaptive.com/services/api/RKM/getPeopleAndBusiness", {
          method: "GET",
          headers: {
            Authorization: authToken,
          }
        })
        .then((res) => res.json());
        showGraph(data);
      }
      // Calling that async function
      fetchGraphData();

      

      function showGraph(dummyData) {

        /* eslint-disable default-case */
        var companyNodeOptions = {
          color: '#00CC96',
          textColor:"#444444",
          radius:30
        }
        var peopleNodeOptions = {
          color: '#636EFA',
          textColor:"#ffffff",
          radius: 20
        }

        console.log("dummyData", dummyData);
        let entity = dummyData["ENTITY"];  
        let meta_relationship_def = dummyData["META_RELATIONSHIP_DEF"];
        let rt_record_relation = dummyData["RT_RECORD_RELATION"];
        let edgeColorsMasterList = ["#e6194B", "#00ff00", "#0000ff", "#42d4f4", "#bfef45",  "#911eb4", "#808000"];
        const getRandomEdgeColor = arr => arr.splice((Math.random() * arr.length) | 0, 1);
        
        let edgeColors = {};
        var meta_relationship_dict = {};
        for (var i = 0; i < meta_relationship_def.length; i++) {
            meta_relationship_dict[meta_relationship_def[i]["ID"]] = meta_relationship_def[i]["RELDESC1TO2"];
            edgeColors[meta_relationship_def[i]["ID"]] = getRandomEdgeColor(edgeColorsMasterList)[0];
        }

        let nodes = [];
        for (let i = 0; i < entity.length; i++) {
            let node_id = entity[i]["ID"];
            var nodeOptions = peopleNodeOptions;
            if(node_id.includes("BUSIN")){
              nodeOptions = companyNodeOptions;
            };

            let node = {
                id: node_id,
                marker: {
                  radius: nodeOptions["radius"]
                },
                info: entity[i]["NAME"],
                color: nodeOptions["color"],  
            };
            nodes.push(node);
        };
        console.log("nodes", nodes);

        let edges = [];
        for (let i = 0; i < rt_record_relation.length; i++) {
            let edge = rt_record_relation[i];
            
            edges.push({
                from: edge["ID1"], 
                to: edge["ID2"],
                reln_id: edge["RELTYPE_ID"],
                color: edgeColors[edge["RELTYPE_ID"]],
                description: meta_relationship_dict[edge["RELTYPE_ID"]],
                width:2,
                // use labelrank in case of collission of edges: https://api.highcharts.com/highcharts/series.networkgraph.data
            });
        };
        console.log(edges); 

        Highcharts.chart('container', {
          chart: {
            type: 'networkgraph',
            marginTop: 80
          },

          title: {
            text: 'Radaptive network graph demo'
          },

          tooltip: {
            formatter: function () {
              let tooltipInfo = `<b>ID</b>: ${this.key}<br/><b>NAME</b>: ${this.point.info}`;
              return tooltipInfo;
            }
          },

          plotOptions: {
            networkgraph: {
              keys: ['from', 'to'],
              layoutAlgorithm: {
                enableSimulation: true,
                integration: 'verlet',
                linkLength: 200
              }
            }
          },

          series: [
            {
              dataLabels: {
                enabled: true,
                linkFormat: "{point.description}",
                allowOverlap: true,
                style: {
                  textOutline: true
                },
                linkTextPath:"some"
              },
              data: edges,
              nodes: nodes
            }
          ]
        });
      }
    </script>
  </body>
</html>